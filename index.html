<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Zeddychan is a public playground. We can both be anonymous and share our thoughts each day. We love horror, conspiracies and some memes.">
    <title>Zeddychan</title>

    <link href="https://fonts.googleapis.com/css2?family=8bit+Operator&display=swap" rel="stylesheet">

    <script src='https://cdn.firebase.com/js/client/2.2.1/firebase.js'></script>
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js'></script>


    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1 class="neon-title">Zeddychan</h1>

        <div class='slider'>
            <div class="edge"></div>
            <ul class="slideContainer"></ul>
        </div>
        
        <script>
            // Polyfill for requestAnimationFrame
            window.requestAnimationFrame = (function(){
                return window.requestAnimationFrame ||
                       window.webkitRequestAnimationFrame ||
                       window.mozRequestAnimationFrame ||
                       function(callback){
                           window.setTimeout(callback, 1000 / 60);
                       };
            })();
        
            // Sentence you want to split into letters
            var sentence = "Zeddychan is a public playground. We can both be anonymous and share our thoughts each day. We love horror, conspiracies and some memes.";
        
            // Gap between letters (in pixels)
            var letterGap = -7; // Default gap between letters
            var spaceGap = 10; // Special gap for spaces
            var endGap = 60; // Special gap for the end of the sentence
            var speed = 0.15; // Speed of animation in seconds
            var isAnimating = false; // Prevents multiple animations from triggering simultaneously

            // Select the container
            var slideContainer = document.querySelector('.slideContainer');
        
            // Split the sentence into individual letters
            var letters = sentence.split('');
        
            // Generate each letter as a list item
            letters.forEach(function(letter, index) {
                var li = document.createElement('li');
                li.classList.add('slideItem');
                li.textContent = letter;
        
                // Apply specific gap for spacebar, end of sentence, and general gap for others
                if (letter === ' ') {
                    li.style.marginRight = spaceGap + 'px'; // Special gap for spaces
                } else if (index === letters.length - 1) {
                    li.style.marginRight = endGap + 'px'; // Special gap for end of sentence
                } else {
                    li.style.marginRight = letterGap + 'px'; // Apply the general gap
                }
        
                slideContainer.appendChild(li);
            });
        
        
            function currencySlide() {
                if (isAnimating) return; // Exit if an animation is already in progress
                isAnimating = true;
        
                var slideItems = document.querySelectorAll('.slideItem');
                var firstItemWidth = slideItems[0].offsetWidth + (
                    slideItems[0].textContent === ' ' ? spaceGap : 
                    (slideItems[0].textContent === letters[letters.length - 1] ? endGap : letterGap)
                ); // Include gap based on letter or end of sentence
        
                // Set the container's width to fit all the items
                var totalWidth = Array.from(slideItems).reduce(function(sum, item, index) {
                    var gap = (item.textContent === ' ') ? spaceGap :
                              (index === slideItems.length - 1) ? endGap : letterGap; // Adjust gap based on position and letter
                    return sum + item.offsetWidth + gap;
                }, 0);
                slideContainer.style.width = totalWidth + 'px';
        
                // Start the sliding animation
                slideContainer.style.transition = `transform ${speed}s linear`;
                slideContainer.style.transform = `translateX(-${firstItemWidth}px)`;
        
                // Use a single event listener for transition end
                slideContainer.addEventListener('transitionend', function handler() {
                    // Move the first item to the end of the list
                    slideContainer.appendChild(slideItems[0]);
        
                    // Reset the transition and transform position
                    slideContainer.style.transition = 'none';
                    slideContainer.style.transform = 'translateX(0)';
        
                    // Allow animation to happen again
                    isAnimating = false; // Reset the flag
                    slideContainer.removeEventListener('transitionend', handler); // Clean up event listener
                    requestAnimationFrame(currencySlide); // Start the next cycle
                }, { once: true }); // Ensure the event listener only fires once per transition
            }
        
            currencySlide(); // Start the sliding effect
        </script>
        




    </div>
    <div class="annPos">
        <button title="&#41;" class="announcement" id="announcement" onclick="goToAnn()">  
        </button>
        <button class="close-announcement" id="close-announcement" onclick="closeAnn()">
        X</button>
    </div>
    </header>
    <hr>
    <p class="bns">
            WELCOME NERDS
    </p>
    <hr>

    <div class="cardcontainer">
        <div class="card">
            <p>This is where I put all of the things that are interesting to us</p>
            <div class="grid">
                <div class="section left">
                    <h2>Stuff</h2>
                    <p id="note">cool stuff</p>
                    <p>Music Stash</p>
                    <p>Sources Of Happiness</p>
                </div>
                <div class="section right">
                    <h2>More stuff</h2>
                    <p id="note">cool vibes</p>
                    <p>Sweetcore</p>
                    <p>...</p>
                </div>
            </div>
        </div>
    </div>

    <div class="audio-player">
        <!-- Custom Controls -->
        <div class="controls">
            <button id="play-pause" class="play">Play</button>
            <input type="range" id="seek-bar" value="0" max="100" step="1" style="width: 300px;">
            <span id="current-time" class="time">0:00</span> / 
            <span id="duration" class="time">0:00</span>
        </div>
        <!-- https://www.youtube.com/embed/pR0HQUSnGTA?enablejsapi=1&autoplay=1&loop=1&playlist=pR0HQUSnGTA -->
        <!-- Visible iframe for YouTube video -->
        <div id="player"></div>
    </div>
    
<style>
   
</style>
<script>
    let player;
    let isPlaying = true; // Assume video starts autoplaying
    const rickRollVideoId = 'dQw4w9WgXcQ'; // Rick Astley's "Never Gonna Give You Up"
    const originalVideoId = 'pR0HQUSnGTA'; // Replace with your original video ID

    // Load YouTube IFrame Player API
    function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            videoId: getRandomVideoId(), // Get the video ID based on chance
            playerVars: {autoplay:1, loop:1},
            events: {
                'onReady': onPlayerReady,
                
                'onStateChange': onPlayerStateChange
            }
        });
    }

    // Function to decide which video ID to use
    function getRandomVideoId() {
        const randomNumber = Math.random();
        return randomNumber <= 0.4 ? originalVideoId : rickRollVideoId;
    }

    // When the player is ready, update the seek bar and duration
    function onPlayerReady(event) {
        const playPauseButton = document.getElementById('play-pause');
        const seekBar = document.getElementById('seek-bar');
        const currentTimeDisplay = document.getElementById('current-time');
        const durationDisplay = document.getElementById('duration');

        // Play/Pause functionality
        playPauseButton.addEventListener('click', () => {
            if (isPlaying) {
                player.pauseVideo();
                playPauseButton.innerText = 'Play';
            } else {
                player.playVideo();
                playPauseButton.innerText = 'Pause';
            }
            isPlaying = !isPlaying;
        });

        // Seek bar functionality
        seekBar.addEventListener('input', () => {
            const seekTo = player.getDuration() * (seekBar.value / 100);
            player.seekTo(seekTo);
        });

        // Update the seek bar and current time periodically
        setInterval(() => {
            const currentTime = player.getCurrentTime();
            const duration = player.getDuration();
            const progress = (currentTime / duration) * 100;

            seekBar.value = progress;

            // Update time display
            currentTimeDisplay.textContent = formatTime(currentTime);
            durationDisplay.textContent = formatTime(duration);
        }, 1000);

        player.playVideo();
    }

    // When the player state changes, ensure the button updates accordingly
    function onPlayerStateChange(event) {
        if (event.data == YT.PlayerState.PAUSED || event.data == YT.PlayerState.ENDED) {
            document.getElementById('play-pause').innerText = 'Play';
            isPlaying = false;
        } else if (event.data == YT.PlayerState.PLAYING) {
            document.getElementById('play-pause').innerText = 'Pause';
            isPlaying = true;
        }
    }

    // Format time in mm:ss
    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    }

    // Load the YouTube API script dynamically
    const tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    document.head.appendChild(tag);

</script>

    
    
    
    



    <h1 class="topic">
        Music Stash
    </h1>
    <div id="videoContainer"></div>

    <h1 class="topic">
       Sources of Happiness
    </h1>
    <div class="hpns" >
        <p>My one and only Beans</p>
        <!-- <p><a 
            href="x" 
            target="_blank" rel="noopener noreferrer">x</a></p> -->
        <p><a 
            href="https://www.twitch.tv/dantes" 
            target="_blank" 
            rel="noopener noreferrer">https://www.twitch.tv/dantes</a></p>
        <p><a 
            href="https://www.youtube.com/@DoaenelYT" 
            target="_blank" 
            rel="noopener noreferrer">https://www.youtube.com/@DoaenelYT</a></p>
        <p><a 
            href="https://www.twitch.tv/ishowspeed" 
            target="_blank" 
            rel="noopener noreferrer">https://www.twitch.tv/ishowspeed</a></p>
        <p><a 
            href="https://www.youtube.com/@IShowSpeed" 
            target="_blank" 
            rel="noopener noreferrer">https://www.youtube.com/@IShowSpeed</a></p>
        <p><a 
            href="https://plaza.one/" 
            target="_blank" 
            rel="noopener noreferrer">https://plaza.one/</a></p>
    </div>

    <div class="tops">
    <div class="OnTopOptions">
        <div class="chat-container">
            <div id="chatbox" class="neon-chatbox">
                <div class="chat-header">
                    <button onclick="toggleChatbox()">Public Lobby</button>
                </div>
                <div class="messages" id="messages"></div>
                <div id="statusMessage" class="status-message" style="color: red;">Loading messages...</div>
                <div id="userInfo" class="user-info" style="color: rgb(82, 134, 255);"></div>
                <input type="text" id="messageInput" class="message-input" placeholder="Type a message..." />
                <button id="sendButton" class="send-button" onclick="sendMessage()">Send</button>
                <div id="chatoptions">
                    <button id="claimButton" class="claim-button" onclick="claimDisplayName()">display name options</button>
                    <button class="minimize-button" onclick="toggleChatbox()">&#x25BC;</button>
                </div>
                <div id="claim" class="claim" style="color: rgba(36, 102, 255, 0.711);">
                    <div id="descLogin" class="desc-login" style="color: rgba(183, 182, 255, 0.855);">Claim display name with seamless login, register, name, pw change:</div>
                    <input type="text" id="displayNameInput" class="display-name-input" placeholder="Enter your display name..." />
                    <input type="text" id="emailInput" class="name-input" placeholder="Enter your email..." />
                    <input type="password" id="passwordInput" class="password-input" placeholder="Enter your password..." />
                    <button id="forgotPasswordButton" class="forgot-password-button" onclick="forgotPassword()">Forgot Password?</button>
                    <button id="signOutButton" class="sign-out-button" onclick="signOut()">sign out</button>
                </div>
            </div>
            <button id="openChatButton" class="ishidden" onclick="toggleChatbox()">Open Chat</button>
        </div>
    </div>
    <script type="module">
          // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
        import { getDatabase, ref as dbRef, onValue, push, set, update, get } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js";
        import { getStorage,  ref as storageRef,  listAll, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-storage.js";
        import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, sendPasswordResetEmail, signOut } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";

        document.addEventListener("DOMContentLoaded", function() {
            if (window.location.href === "https://zeddychan.netlify.app/" || window.location.href === "http://127.0.0.1:5500/index.html") {
                document.body.classList.remove('hide');

                // Array of YouTube links
        let musiclist = [

            "https://www.youtube.com/watch?v=dQw4w9WgXcQ",
            "https://www.youtube.com/watch?v=2Vv-BfVoq4g",
            "https://www.youtube.com/watch?v=lI-rZIdOZ6o"
        ];

        // Function to create iframes from the YouTube links
        function embedYouTubeVideos(videoList) {
            const container = document.getElementById("videoContainer"); // Get the container div
            
            videoList.forEach(link => {
                // Extract video ID from the YouTube link
                const videoId = link.split("v=")[1];
                const ampersandPosition = videoId.indexOf("&");
                if (ampersandPosition !== -1) {
                    videoId = videoId.substring(0, ampersandPosition);
                }

                // Create the iframe element
                const iframe = document.createElement("iframe");
                iframe.className = "musicstashembed";
                iframe.width = "260";
                iframe.height = "147";
                iframe.src = `https://www.youtube.com/embed/${videoId}`;
                iframe.title = "YouTube video player";
                iframe.frameBorder = "0";
                iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
                iframe.allowFullscreen = true;

                // Append the iframe to the container
                container.appendChild(iframe);
            });
        }

        // Call the function to embed videos
        embedYouTubeVideos(musiclist);

        const firebaseConfig = {
            apiKey: "AIzaSyCcV2wJ2tvOYEH_tW1sIi3YXOURy6h7VTo",
            authDomain: "zeddychan.firebaseapp.com",
            databaseURL: "https://zeddychan-default-rtdb.firebaseio.com",
            projectId: "zeddychan",
            storageBucket: "zeddychan.appspot.com",
            messagingSenderId: "556479718409",
            appId: "1:556479718409:web:c6bfd066216922f35484d8",
            measurementId: "G-8W0CHH4G68"
        };

        const app = initializeApp(firebaseConfig);
        const database = getDatabase(app);
        const auth = getAuth(app);
        const storage = getStorage();
        const imagesRef = storageRef(storage, 'images');

        const sendButton = document.getElementById("sendButton");
        const claimButton = document.getElementById("claimButton");
        const emailInput = document.getElementById("emailInput");
        const passwordInput = document.getElementById("passwordInput");
        const messageInput = document.getElementById("messageInput");
        const chatbox = document.getElementById("chatbox");
        const openChatButton = document.getElementById("openChatButton");
        const statusMessageDiv = document.getElementById("statusMessage");
        const userInfoDiv = document.getElementById("userInfo");
        const signOutButton = document.getElementById("signOutButton");
        const announcementDiv = document.getElementById('announcement');
        const closeAnnouncementDiv = document.getElementById('close-announcement');

        
        // Reference to publicAnnouncement in your database
        const announcementRef = dbRef(database, 'publicAnnouncement');
        let announcementLink = "";

         // Listen for value changes using onValue
         onValue(announcementRef, (snapshot) => {
            const announcementData = snapshot.val();
            announcementLink = announcementData.link;
            if (announcementData && announcementData.message) {
                announcementDiv.textContent = `${announcementData.title}: ${announcementData.message}`; // Update the announcement text
                announcementDiv.style.display = 'block'; // Show the announcement
                closeAnnouncementDiv.style.display = 'block';
                document.getElementById('announcement').title = announcementLink;
                console.log(announcementDiv.textContent);

            } else {
                announcementDiv.style.display = 'none'; // Hide if no announcement
                console.log("No ann");

            }
        });
        window.closeAnn = function() {
            announcementDiv.style.display = 'none';
            closeAnnouncementDiv.style.display = 'none';
        }
        window.goToAnn = function() {
            if (announcementLink === ""){
            } else{
                const userConfirmed = confirm(`Are you sure you want to go to ${announcementLink}?`);
                
                // If the user confirms, navigate to the link
                if (userConfirmed) {
                    window.open(announcementLink, '_blank');
                }
            }
        }
        
        onAuthStateChanged(auth, (user) => {
            checkUser(user);
        });
        function checkUser() {
            // CHECK CURRENT USER
            const user = auth.currentUser;

            if (user) {
                statusMessageDiv.textContent = "Hello, human.";

                const userEmail = user.email;
                const userRef = dbRef(database, `users/${auth.currentUser.uid}`);

                // Fetch display name from the database
                onValue(userRef, (snapshot) => {
                    const userData = snapshot.val();
                    const displayName = userData ? userData.displayName || 'Anonymous' : 'Anonymous';

                    updateUIForLoggedInUser(displayName); // Use the actual displayName here
                    signOutButton.style.display = "block";
                });
            }
        }
        userInfoDiv.textContent = "Anonymous";
        //signOutButton.style.display = "block";
        function loadMessages() {
            
            statusMessageDiv.textContent = "Loading messages...";
            setTimeout(() => {
            const messagesRef = dbRef(database, 'publicChatRooms/defaultRoom/messages');
            onValue(messagesRef, (snapshot) => {
                chatbox.style.display = 'flex' ;
                openChatButton.style.display ='none';

                const messages = snapshot.val();
                const messagesDiv = document.getElementById("messages");
                messagesDiv.innerHTML = '';

                for (const key in messages) {
                    const message = messages[key];
                    const messageElement = document.createElement("div");
                    messageElement.className = "message";
                    messageElement.textContent = `${message.name || 'Anonymous'}: ${message.text} (sent at ${new Date().toLocaleTimeString()} )`;
                    messagesDiv.appendChild(messageElement);
                }
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                sendButton.disabled = false;
            }, (error) => {
                console.error("Error reading data:", error);
                statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                sendButton.disabled = true;
            });
            statusMessageDiv.textContent = "";}, 310);
        }
        sendButton.disabled = true;

        loadMessages();
        let isSendingMessage = false;
        let isBusySending = false;

        let existingDisplayNames = [];

        const publicDisplayNamesRef = dbRef(database,'publicDisplayNames');

        onValue(publicDisplayNamesRef, (snapshot) => {
        const allDisplayNames = snapshot.val();
        
        // Extract display names from the data
        existingDisplayNames = Object.values(allDisplayNames || {}).map(user => user.displayName);
        
            // Log all display names
            //console.log("All Public Display Names:", existingDisplayNames);
        }, (error) => {
            console.error("Error fetching public display names:", error);
        });

        let openedClaimBox = false;

        window.claimDisplayName = function() {
            if (!openedClaimBox){
                // Display a confirmation dialog
                const userConfirmed = confirm("You will need to claim your display name using an email address and a password of your choice. Please create a random password that you do not use elsewhere, and reserve it solely for this page. I can view your email address but will not have access to it.");

                // If the user clicks Cancel, return early
                if (!userConfirmed) {
                    return;
                }
            }

            const claimDiv = document.getElementById('claim');
            if (claimDiv.style.display === "none" || claimDiv.style.display === "") {
                openedClaimBox = true;
                claimDiv.style.display = "contents"; // Show the contents
            } else {
                openedClaimBox = false;
                claimDiv.style.display = "none"; // Hide the contents
            }
        }

        // ---------------------------------------------------------SENDING A MESSAGE
        window.sendMessage = function() {

        if (isSendingMessage) return;
        isSendingMessage = true;

        console.log("sendMessage called");
        sendButton.disabled = true;
        statusMessageDiv.textContent = "Loading...";

        setTimeout(() => {
        const messageText = messageInput.value.trim();
        const userEmail = emailInput.value.trim();
        const userPassword = passwordInput.value.trim();

        if (messageText === "") {
            statusMessageDiv.textContent = "Input is required.";
            sendButton.disabled = false;
            return;
        }

        // Get the current user
        const user = auth.currentUser;

        if (user) {
            console.log("Sending with user");

            const userEmail = user.email;
            const userRef = dbRef(database, `users/${auth.currentUser.uid}`);
            if (displayNameInput.value !== "") {
                if (existingDisplayNames.includes(displayName)) {
                    console.log("ALREADY TAKEN");
                    statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                    sendButton.disabled = false;
                    return; // Return false if the name is taken
                }
                saveDisplayName(userEmail, displayNameInput.value.trim());
            }
            // Fetch display name from the database
            get(userRef).then((snapshot) => {
                if (isBusySending) return;
                isBusySending = true;

                const userData = snapshot.val();
                const displayName = userData.displayName || 'Anonymous';

                const messageData = {
                    name: displayName,
                    text: messageText,
                    timestamp: Date.now(),
                    ownerId: auth.currentUser.uid
                };

                push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                    .then(() => {
                        updateUIForLoggedInUser(displayName);
                        messageInput.value = "";
                        statusMessageDiv.textContent = `Message sent. ${new Date(Date.now()).toLocaleTimeString()}`;
                        passwordInput.value = ""; // Clear password
                        displayNameInput.value = "";
                    })
                    .catch((error) => {
                        console.error("Error writing data:", error);
                        statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                    });
            });
        } 
        else {


        // Check if email is provided
        if (userEmail === "") {
                // Send as anonymous
                const messageData = {
                    name: "Anonymous",
                    text: messageText,
                    timestamp: Date.now(),
                    ownerId: "anon"
                };
                push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                    .then(() => {
                        console.log("anonymous push called");
                        messageInput.value = "";
                        statusMessageDiv.textContent = "Message sent as Anonymous.";
                        userInfo.textContent = "Anonymous";
                        sendButton.disabled = false;
                    })
                    .catch((error) => {
                        console.error("Error writing data:", error);
                        statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                        sendButton.disabled = true;
                    });
            } else {
                    // Attempt to login/register
                    signInWithEmailAndPassword(auth, userEmail, userPassword)
                        .then(() => {
                            sendButton.disabled = true;
                            if (displayNameInput.value !== "") {
                                if (existingDisplayNames.includes(displayNameInput.value)) {
                                    console.log("ALREADY TAKEN");
                                    statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                                    sendButton.disabled = false;
                                    return; // Return false if the name is taken
                                }
                                saveDisplayName(userEmail, displayNameInput.value.trim());
                            }
                            // Fetch the display name from the database
                            const userRef = dbRef(database, `users/${auth.currentUser.uid}`);
                            get(userRef).then((snapshot) => {
                                if (isBusySending) return;
                                 isBusySending = true;

                                const userData = snapshot.val();
                                const displayName = userData.displayName || 'Error loading name';

                                const messageData = {
                                    name: displayName, // Use display name from database
                                    text: messageText,
                                    timestamp: Date.now(),
                                    ownerId: auth.currentUser.uid
                                };
                                
                                push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                                .then(() => {
                                    console.log("signed in sent message called");
                                    statusMessageDiv.textContent = "";
                                    
                                    messageInput.value = "";
                                    passwordInput.value = ""; // Clear password
                                    updateUIForLoggedInUser(displayName);
                                    displayNameInput.value = "";
                                    
                                    sendButton.disabled = false;
                                    
                                })
                                .catch((error) => {
                                    console.error("Error writing data:", error);
                                    statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                                    sendButton.disabled = true;
                                });  
                            }).catch((error) => {
                                console.error('Error fetching user data on sign in!!:', error);
                                statusMessageDiv.textContent = "Error";
                            });
                        })
                        .catch((error) => {
                            sendButton.disabled = true;

                            if (error.code === 'auth/user-not-found') {
                                // Not registered, attempt to register
                                let displayName = displayNameInput.value.trim();
                                displayName = displayName === "" ? generateDisplayNameWithToken() : displayName;
                                if (existingDisplayNames.includes(displayName)) {
                                    console.log("ALREADY TAKEN");
                                    statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                                    sendButton.disabled = false;
                                    return; // Return false if the name is taken
                                }
                                console.log("Sending with user2");
                                createUserWithEmailAndPassword(auth, userEmail, userPassword)
                                    .then(() => {
                                        if (!saveDisplayName(userEmail, displayName)){
                                            console.log("FAILED DISPLAY NAME");
                                            statusMessageDiv.textContent =  "Failed.";
                                        }
                                        const messageData = {
                                            text: messageText,
                                            name: displayName,
                                            timestamp: Date.now(),
                                            ownerId: auth.currentUser.uid
                                        };

                                        push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                                            .then(() => {
                                                statusMessageDiv.textContent = "";
                                                console.log("registration 01 push called");
                                                messageInput.value = "";
                                                passwordInput.value = ""; // Clear password
                                                updateUIForNewRegisteredInUser(displayName);
                                                sendButton.disabled = false;
                                            })
                                            .catch((error) => {
                                                console.error("Error writing data:", error);
                                                statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                                                sendButton.disabled = true;
                                            });
                                    })
                                    .catch((error) => {
                                        statusMessageDiv.textContent = error.message;
                                    });
                                
                            } else if (error.code === 'auth/invalid-credential') {
                                console.log("Sending with user3");

                                let displayName = displayNameInput.value.trim();
                                displayName = displayName === "" ? generateDisplayNameWithToken() : displayName;
                                if (existingDisplayNames.includes(displayName)) {
                                    console.log("ALREADY TAKEN");
                                    statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                                    sendButton.disabled = false;
                                    return; // Return false if the name is taken
                                }
                                    createUserWithEmailAndPassword(auth, userEmail, userPassword)
                                    .then(() => {
                                         if (!saveDisplayName(userEmail, displayName)){
                                            console.log("FAILED DISPLAY NAME");
                                            statusMessageDiv.textContent =  "Failed.";
                                        }
                                        const messageData = {
                                            text: messageText,
                                            name: displayName,
                                            timestamp: Date.now(),
                                            ownerId: auth.currentUser.uid
                                        };

                                        push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                                            .then(() => {
                                                statusMessageDiv.textContent = "";
                                                console.log("registration 02 push called");
                                                messageInput.value = "";
                                                passwordInput.value = ""; // Clear password
                                                updateUIForNewRegisteredInUser(displayName);
                                                sendButton.disabled = false;

                                            })
                                            .catch((error) => {
                                                console.error("Error writing data:", error);
                                                statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                                                sendButton.disabled = true;
                                            });
                                    })
                                    .catch((error) => {
                                        statusMessageDiv.textContent = "Something went wrong. Please try it again or nech an696 9 at gmaildotcom for support. or make sure your password is correct.";
                                    });
                               
                            } else if (error.code === 'auth/missing-password') {
                                statusMessageDiv.textContent =  "Enter password.";
                            } else {
                                // Handle other errors
                                statusMessageDiv.textContent = "Too many attempts or something went wrong. Please try it again later or nech an696 9 at gmaildotcom for support. - or make sure your password is correct.";
                            }
                        });
                }
            }
            isSendingMessage = false;
            isBusySending = false;

            }, 1250);

            isSendingMessage = false;
            isBusySending = false;
        }
        let isBusyUpdatingName = false;


        async function saveDisplayName(userEmail, displayName) {
            if (isBusyUpdatingName) return false; // Return false if already busy
            
            isBusyUpdatingName = true;

            if (existingDisplayNames.includes(displayName)) {
                console.log("ALREADY TAKEN");
                statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                sendButton.disabled = false;
                isBusyUpdatingName = false; // Reset the busy state
                return false; // Return false if the name is taken
            }

            const userRef = dbRef(database, `users/${auth.currentUser.uid}`);
            const publicDisplayNamesRef  = dbRef(database, `publicDisplayNames/${auth.currentUser.uid}`);
            try {
                await update(userRef, { 
                    displayName, 
                    email: userEmail 
                });
                await set(publicDisplayNamesRef, { displayName })
                .then(() => {
                    console.log("Display name updated successfully!");
                })
                .catch((error) => {
                    console.error("Error updating display name:", error);
                });

                statusMessageDiv.textContent = "Display name changed.";
                console.log("Display name changed.");
                return true; // Return true on success
            } catch (error) {
                console.error("Error writing data:", error);
                statusMessageDiv.textContent = error.message;
                return false; // Return false on error
            } finally {
                isBusyUpdatingName = false; // Reset the busy state
            }
        }


        function generateDisplayNameWithToken() {
            let randomToken;
            
            // Generate a unique token
            do {
                randomToken = Math.random().toString(36).substring(2, 12);
            } while (existingDisplayNames.includes(`User_${randomToken}`)); // Check for duplicates

            return `User_${randomToken}`; // Return the unique display name
        }

        function updateUIForLoggedInUser(displayName) {
            passwordInput.style.display = "none";
            displayNameInput.style.display = "none";
            userInfo.textContent = `Welcome ${displayName}.`;
        }

        function updateUIForNewRegisteredInUser(displayName) {
            passwordInput.style.display = "none";
            displayNameInput.style.display = "none";
            userInfo.textContent = `Welcome ${displayName}.`;
        }

        window.toggleChatbox = function() {
            const isMinimized = chatbox.style.display === 'none';
            chatbox.style.display = isMinimized ? 'flex' : 'none';
            openChatButton.style.display = isMinimized ? 'none' : 'block';
        }

        window.forgotPassword = function() {
            const userEmail = emailInput.value.trim();

            if (userEmail === "") {
                statusMessageDiv.textContent = "Please enter your email address.";
                return;
            }

            sendPasswordResetEmail(auth, userEmail)
                .then(() => {
                    statusMessageDiv.textContent = "If you are registered, you will receive a password reset email.";
                })
                .catch((error) => {
                    console.error(error); 
                    statusMessageDiv.textContent = "If you are registered, you will receive a password reset email.";
                });
        }
        function resetUIForLoggedOutUser() {
            passwordInput.style.display = "block"; // Show password input
            displayNameInput.style.display = "block"; // Show display name input
            emailInput.value = ""; // Clear email input
            passwordInput.value = ""; // Clear password input
            displayNameInput.value = ""; // Clear display name input
            userInfo.textContent = "";
            signOutButton.style.display = "none";
        }

        window.signOut = function() {
            signOut(auth)
                .then(() => {
                    // Sign-out successful.
                    statusMessageDiv.textContent = "You have been signed out.";
                    resetUIForLoggedOutUser(); // Reset UI for logged out state
                })
                .catch((error) => {
                    console.error("Error signing out:", error);
                    statusMessageDiv.textContent = "Error signing out. Please try again.";
                });
        };

    let showDraggables = true;
    if (showDraggables) {
        
        listAll(imagesRef).then((res) => {
    if (res.items.length > 0) {
        res.items.forEach((itemRef) => {
            // Get download URL for each image
            getDownloadURL(itemRef).then((url) => {
                createDraggableImage(url); // Create draggable image for each URL
            }).catch((error) => {
                console.error("Error getting image URL:", error);
            });
        });
    } else {
        console.log("No images found.");
    }
}).catch((error) => {
    console.error("Error listing images:", error);
});

// Function to create draggable images
function createDraggableImage(imageUrl) {
    const img = document.createElement('img');
    img.src = imageUrl;
    img.className = 'draggable';
    img.style.position = 'absolute';
    img.style.width = '100px'; // Set a width
    img.style.height = '100px'; // Set a height
    img.setAttribute('draggable', false); // Prevent default dragging behavior

    const maxWidth = window.innerWidth - 100; // Adjust for element width
    const maxHeight = window.innerHeight - 100; // Adjust for element height
    const randomLeft = Math.floor(Math.random() * maxWidth);
    const randomTop = Math.floor(Math.random() * maxHeight);
    img.style.left = randomLeft + 'px';
    img.style.top = randomTop + 'px';

    document.body.appendChild(img);
    makeDraggable(img);
}

// Function to make images draggable on both desktop and mobile
function makeDraggable(element) {
    let offsetX, offsetY;

    // Desktop: mouse down event
    element.addEventListener('mousedown', (e) => {
        e.preventDefault(); // Prevent default behavior like selecting text or dragging

        // Calculate the offset between the mouse click position and the image's position
        const rect = element.getBoundingClientRect();
        offsetX = e.clientX - rect.left; // Horizontal offset
        offsetY = e.clientY - rect.top; // Vertical offset

        // Add event listeners for moving the image
        document.addEventListener('mousemove', mouseMoveHandler);
    });

    // Mobile: touch start event
    element.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent default behavior like scrolling

        const touch = e.touches[0]; // Only consider the first touch point
        const rect = element.getBoundingClientRect();
        offsetX = touch.clientX - rect.left; // Horizontal offset
        offsetY = touch.clientY - rect.top; // Vertical offset

        // Add event listeners for moving the image on touch devices
        document.addEventListener('touchmove', touchMoveHandler);
    });

    function mouseMoveHandler(e) {
        // Calculate the new position of the image, accounting for scroll
        const newX = e.clientX - offsetX + window.scrollX; // Horizontal position, adjusted for horizontal scroll
        const newY = e.clientY - offsetY + window.scrollY; // Vertical position, adjusted for vertical scroll

        moveElementToPosition(newX, newY);
    }

    function touchMoveHandler(e) {
        const touch = e.touches[0]; // Only consider the first touch point
        const newX = touch.clientX - offsetX + window.scrollX; // Horizontal position, adjusted for horizontal scroll
        const newY = touch.clientY - offsetY + window.scrollY; // Vertical position, adjusted for vertical scroll

        moveElementToPosition(newX, newY);
    }

    function moveElementToPosition(newX, newY) {
        const viewportWidth = window.innerWidth + window.scrollX; // Adjust for horizontal scroll
        const viewportHeight = window.innerHeight + window.scrollY; // Adjust for vertical scroll

        // Ensure the image stays within the viewport
        const constrainedX = Math.max(0, Math.min(newX, viewportWidth - element.offsetWidth));
        const constrainedY = Math.max(0, Math.min(newY, viewportHeight - element.offsetHeight));

        // Update the position of the image
        element.style.left = `${constrainedX}px`;
        element.style.top = `${constrainedY}px`;
    }

    // Stop moving the image when mouse is released
    document.addEventListener('mouseup', () => {
        document.removeEventListener('mousemove', mouseMoveHandler);
    });

    // Stop moving the image when touch ends
    document.addEventListener('touchend', () => {
        document.removeEventListener('touchmove', touchMoveHandler);
    });
}


}
} else {
    document.body.innerHTML = 'Error. Come back again later.'; 
    confirm("Error. Come back again later.");

    return; 
    }
});
</script>



<div id="typebns">
<p id="typewriter" class= "bns"></p>
<p id="blinker-pos"></p>
</div>
<script>
      const text = "Beans is and will forever be my one and only!";
    const typewriterElement = document.getElementById("typewriter");
    const blinkerElement = document.getElementById("blinker-pos");
    let index = 0;
 // Create and append the cursor at the beginning
    const blinkCursor = document.createElement("span");
    blinkCursor.className = "cursor"; // Apply the cursor styles
    blinkerElement.appendChild(blinkCursor); // Append cursor initially
    function typeWriter() {
        if (index < text.length) {
            typewriterElement.textContent += text.charAt(index); // Add the next character
            index++;
            
            // Move the cursor to the end
            setTimeout(typeWriter, 160); // Adjust the speed (160ms between characters)
        } else {
            // Optionally, you can remove the cursor after some time
            setTimeout(() => {
                blinkerElement.remove(); // Remove the cursor
            }, 3000); // Adjust this value to keep the cursor longer or shorter
        }
    }

    // Start the typewriter effect
    typeWriter();
</script>


</div>
</body>
</html>
