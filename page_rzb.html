<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Reizorbean is our little page in the web where we share our thoughts. We love horror, conspiracies and some memes.">
    <title>reizorbean</title>

    <link href="https://fonts.googleapis.com/css2?family=8bit+Operator&display=swap" rel="stylesheet">

    <script src='https://cdn.firebase.com/js/client/2.2.1/firebase.js'></script>
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js'></script>


    <link rel="stylesheet" href="PageRZBStyle.css">
</head>
<body>
    <div id="pagerzb_bg">

    <script>
        let isInnerHTML = false;

        let cachedData = null; // Variable to store fetched data


        // Check if the page variable is defined
        if (typeof(page) !== "undefined" && page !== null) {
            // This indicates that we are about to insert content via innerHTML
            isInnerHTML = true;
            console.log("Inserted via innerHTML");
        } else {
            console.log("Not inserted via innerHTML");
        }

        async function data() {
            // Check if data has already been fetched
            if (cachedData) {
                return cachedData; // Return cached data if available
            }

            try {
                const response = await fetch('recipes.json');
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                cachedData = await response.json(); // Store the fetched data
                return cachedData; // Return the fetched data
            } catch (error) {
                console.error('There was a problem with the fetch operation:', error);
                return null; // Return null in case of error
            }
        }
    //     (async () => {
    // const recipes = await data();
    // })();

    
        // Before you use innerHTML
        if (typeof(page) !== "undefined"){
            console.log("Inserted via innerHTML");
            // You can call your logic function here if needed
        }else{
            console.log("Not inserted via innerHTML");
        }
    </script>









<!-- the header -->

<header>
        <h1 class="neon-title">Reizorbean</h1>

        <div class='slider'>
            <div class="edge"></div>
            <ul class="slideContainer"></ul>
        </div>
        
        <script>
            // Polyfill for requestAnimationFrame
            window.requestAnimationFrame = (function(){
                return window.requestAnimationFrame ||
                       window.webkitRequestAnimationFrame ||
                       window.mozRequestAnimationFrame ||
                       function(callback){
                           window.setTimeout(callback, 1000 / 60);
                       };
            })();
        
            // Sentence you want to split into letters
            var sentence = "Reizorbean is our little page in the web where we share our thoughts. We love horror, conspiracies and some memes.";
        
            // Gap between letters (in pixels)
            var letterGap = -7; // Default gap between letters
            var spaceGap = 10; // Special gap for spaces
            var endGap = 60; // Special gap for the end of the sentence
            var speed = 0.15; // Speed of animation in seconds
            var isAnimating = false; // Prevents multiple animations from triggering simultaneously

            // Select the container
            var slideContainer = document.querySelector('.slideContainer');
        
            // Split the sentence into individual letters
            var letters = sentence.split('');
        
            // Generate each letter as a list item
            letters.forEach(function(letter, index) {
                var li = document.createElement('li');
                li.classList.add('slideItem');
                li.textContent = letter;
        
                // Apply specific gap for spacebar, end of sentence, and general gap for others
                if (letter === ' ') {
                    li.style.marginRight = spaceGap + 'px'; // Special gap for spaces
                } else if (index === letters.length - 1) {
                    li.style.marginRight = endGap + 'px'; // Special gap for end of sentence
                } else {
                    li.style.marginRight = letterGap + 'px'; // Apply the general gap
                }
        
                slideContainer.appendChild(li);
            });
        
        
            function textSlide() {
                if (isAnimating) return; // Exit if an animation is already in progress
                isAnimating = true;
        
                var slideItems = document.querySelectorAll('.slideItem');
                var firstItemWidth = slideItems[0].offsetWidth + (
                    slideItems[0].textContent === ' ' ? spaceGap : 
                    (slideItems[0].textContent === letters[letters.length - 1] ? endGap : letterGap)
                ); // Include gap based on letter or end of sentence
        
                // Set the container's width to fit all the items
                var totalWidth = Array.from(slideItems).reduce(function(sum, item, index) {
                    var gap = (item.textContent === ' ') ? spaceGap :
                              (index === slideItems.length - 1) ? endGap : letterGap; // Adjust gap based on position and letter
                    return sum + item.offsetWidth + gap;
                }, 0);
                slideContainer.style.width = totalWidth + 'px';
        
                // Start the sliding animation
                slideContainer.style.transition = `transform ${speed}s linear`;
                slideContainer.style.transform = `translateX(-${firstItemWidth}px)`;
        
                // Use a single event listener for transition end
                slideContainer.addEventListener('transitionend', function handler() {
                    // Move the first item to the end of the list
                    slideContainer.appendChild(slideItems[0]);
        
                    // Reset the transition and transform position
                    slideContainer.style.transition = 'none';
                    slideContainer.style.transform = 'translateX(0)';
        
                    // Allow animation to happen again
                    isAnimating = false; // Reset the flag
                    slideContainer.removeEventListener('transitionend', handler); // Clean up event listener
                    requestAnimationFrame(textSlide); // Start the next cycle
                }, { once: true }); // Ensure the event listener only fires once per transition
            }
        
                textSlide(); // Start the sliding effect
        </script>

















    <!-- the announcement -->

    <div class="annPos">
        <button title="&#41;" class="announcement" id="announcement" onclick="goToAnn()">  
        </button>
        <button class="close-announcement" id="close-announcement" onclick="closeAnn()">
        X</button>
    </div>
</header>


<hr>
    <p class="bns">
        WELCOME NERDS
    </p>
<hr>



















    <!-- the card -->


    <div class="cardcontainer">
        <div class="card">
            <p>This is where I put all of the things that are interesting to us</p>
            <div class="grid">
                <div class="section left">
                    <h2>Stuff</h2>
                    <p id="note">yes, cool stuff</p>
                    <p><a class="gotothing" href="#musicstash" style="text-decoration: none; cursor: pointer;">
                     Music Stash</a></p>
                    <p><a  class="gotothing" href="#srchpns" style="text-decoration: none; cursor: pointer;">
                        Sources Of Happiness</a></p>
                </div>
                <div class="section right">
                    <h2>More stuff</h2>
                    <p id="note">cool cool vibes</p>
                    <p><a  class="gotothing" href="#" style="text-decoration: none; cursor: pointer;">
                       Sweetcore</a></p>
                    <p>...</p>
                </div>
            </div>
        </div>
    </div>

    <div class="audio-player">
        <!-- Custom Controls -->
        <div class="controls">
            <button id="play-pause" class="play">Play</button>
            <input type="range" id="seek-bar" value="0" max="100" step="1" style="width: 300px;">
            <span id="current-time" class="time">0:00</span> / 
            <span id="duration" class="time">0:00</span>
        </div>
        <!-- https://www.youtube.com/embed/pR0HQUSnGTA?enablejsapi=1&autoplay=1&loop=1&playlist=pR0HQUSnGTA -->
        <!-- Visible iframe for YouTube video -->
        <div id="player"></div>
    </div>
    
















<!-- the first video player -->


<script>

 // Load YouTube IFrame Player API
 function onYouTubeIframeAPIReady() {
        player = new YT.Player('player', {
            videoId: getRandomVideoId(), // Get the video ID based on chance
            playerVars: {autoplay:1, loop:1},
            events: {
                'onReady': onPlayerReady,
                
                'onStateChange': onPlayerStateChange
            }
        });
    }

    // Function to decide which video ID to use
    function getRandomVideoId() {
        const randomNumber = Math.random();
        return randomNumber <= 0.4 ? originalVideoId : rickRollVideoId;
    }

    // Function to attempt to play the video
    function tryToPlayVideo() {
        player.playVideo();  // Try to play the video

        // Check if the video is actually playing
        const checkIfPlaying = setInterval(() => {
            if (player.getPlayerState() === YT.PlayerState.PLAYING) {
                clearInterval(checkIfPlaying);
                console.log("Video is now playing.");
            } else {
                console.log("Trying to play video again...");
                player.playVideo(); // Try to play the video again if it's not playing
            }
        }, 350); // Check every 1 second
    }

    // When the player is ready, update the seek bar and duration
    function onPlayerReady(event) {
        console.log("VIDEO PLAYER READY");
        setTimeout(function() {

        const playPauseButton = document.getElementById('play-pause');
        const seekBar = document.getElementById('seek-bar');
        const currentTimeDisplay = document.getElementById('current-time');
        const durationDisplay = document.getElementById('duration');

        // Play/Pause functionality
        playPauseButton.addEventListener('click', () => {
            if (isPlaying) {
                player.pauseVideo();
                playPauseButton.innerText = 'Play';
            } else {
                player.playVideo();
                playPauseButton.innerText = 'Pause';
            }
            isPlaying = !isPlaying;
        });

        // Seek bar functionality
        seekBar.addEventListener('input', () => {
            const seekTo = player.getDuration() * (seekBar.value / 100);
            player.seekTo(seekTo);
            console.log("sliding audio bar!")
        });

        // Update the seek bar and current time periodically
        setInterval(() => {
            const currentTime = player.getCurrentTime();
            const duration = player.getDuration();
            const progress = (currentTime / duration) * 100;

            seekBar.value = progress;

            // Update time display
            currentTimeDisplay.textContent = formatTime(currentTime);
            durationDisplay.textContent = formatTime(duration);
        }, 1000);

        tryToPlayVideo();
    }, 200);
    }




    // When the player state changes, ensure the button updates accordingly
    function onPlayerStateChange(event) {
        if (event.data == YT.PlayerState.PAUSED || event.data == YT.PlayerState.ENDED) {
            document.getElementById('play-pause').innerText = 'Play';
            isPlaying = false;
        } else if (event.data == YT.PlayerState.PLAYING) {
            document.getElementById('play-pause').innerText = 'Pause';
            isPlaying = true;
        }
    }

    // Format time in mm:ss
    function formatTime(seconds) {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    }
    // Fetch the music list from the JSON file
    let originalVideoId = ''; // Replace with your original video ID

    let player;
    let isPlaying = true; // Assume video starts autoplaying
    const rickRollVideoId = 'dQw4w9WgXcQ'; // Rick Astley's "Never Gonna Give You Up"

    (async () => {
    const recipes = await data();
    originalVideoId = recipes.firstvideotoplay; 
    console.log(originalVideoId); 

    
    // Load the YouTube API script dynamically
    const tag = document.createElement('script');
    tag.src = "https://www.youtube.com/iframe_api";
    document.head.appendChild(tag);
    })();

</script>

    
    
    
    
















<!-- the topics -->


<h1 class="topic" id="musicstash">
    Music Stash
</h1>
<div id="videoContainer"></div>

<h1 class="topic" id="srchpns">
    Sources of Happiness
</h1>

<div id="p-tags-container" class="hpns"></div>
<script>
    async function generatePTags() {
        // Fetch the data from your source
        const recipes = await data(); // Assume this fetches your JSON data
        const hpns = recipes.hpns; // Access the hpns key (now an array)

        // Get a reference to the container where you want to append the <p> tags
        const container = document.getElementById('p-tags-container');

        // Loop through the hpns array and create <p> elements
        hpns.forEach(item => {
            // Create a new <p> element
            const pTag = document.createElement('p');

            // Check if item has href and text properties
            if (item.href && item.text) {
                // Create the <a> tag
                const aTag = document.createElement('a');
                aTag.href = item.href; // Set the href attribute
                aTag.target = '_blank'; // Open in a new tab
                aTag.rel = 'noopener noreferrer'; // Security best practices
                aTag.textContent = item.text; // Set the link text

                // Append the <a> tag to the <p> tag
                pTag.appendChild(aTag);
            } else {
                // If there is no href, just use the text as plain <p>
                pTag.textContent = item.text;
            }

            // Append the <p> tag to the container
            container.appendChild(pTag);
        });
    }

    // Call the function to generate <p> tags
    generatePTags();
</script>

















<!-- chat -->


    <div class="tops">
    <div class="OnTopOptions">
        <div class="chat-container">
            <div id="chatbox" class="neon-chatbox">
                <div class="chat-header">
                    <button onclick="toggleChatbox()">Public Lobby</button>
                </div>
                <div class="messages" id="messages"></div>
                <div id="statusMessage" class="status-message" style="color: red;">Pending...</div>
                <div id="userInfo" class="user-info" style="color: rgb(82, 134, 255);"></div>
                <input type="text" id="messageInput" class="message-input" placeholder="Type a message..." />
                <button id="sendButton" class="send-button" onclick="sendMessage()">Send</button>
                <div id="chatoptions">
                    <button id="claimButton" class="claim-button" onclick="claimDisplayName()">display name options</button>
                    <button class="minimize-button" onclick="toggleChatbox()">&#x25BC;</button>
                </div>
                <div id="claim" class="claim" style="color: rgba(36, 102, 255, 0.711);">
                    <div id="descLogin" class="desc-login" style="color: rgba(183, 182, 255, 0.855);">Claim display name with seamless login, register, name, pw change:</div>
                    <input type="text" id="displayNameInput" class="display-name-input" placeholder="Enter your display name..." />
                    <input type="text" id="emailInput" class="name-input" placeholder="Enter your email..." />
                    <input type="password" id="passwordInput" class="password-input" placeholder="Enter your password..." />
                    <button id="forgotPasswordButton" class="forgot-password-button" onclick="forgotPassword()">Forgot Password?</button>
                    <button id="signOutButton" class="sign-out-button" onclick="signOut()">sign out</button>
                </div>
            </div>
            <button id="openChatButton" class="ishidden" onclick="toggleChatbox()">Open Chat</button>
        </div>
    </div>



<script type="module">
        // Firebase imports
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
    import { getDatabase, ref as dbRef, onValue, push, set, update, get } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-database.js";
    import { getStorage,  ref as storageRef,  listAll, getDownloadURL } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-storage.js";
    import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, sendPasswordResetEmail, signOut } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";

    console.log("MODULE HERE!!!"); 

    console.log(".......")
    const firebaseConfig = {
        databaseURL: "https://reizorbean-default-rtdb.firebaseio.com",
        apiKey: "AIzaSyDsSFled2cHxIOUBWdD1TR7bvpiU_b5TDQ",
        authDomain: "reizorbean.firebaseapp.com",
        projectId: "reizorbean",
        storageBucket: "reizorbean.appspot.com",
        messagingSenderId: "997740521798",
        appId: "1:997740521798:web:e6914db572a5f449645d47",
        measurementId: "G-5WBWR125F2"
    };

    const app = initializeApp(firebaseConfig);
    const database = getDatabase(app);
    const auth = getAuth(app);
    const storage = getStorage();
    const imagesRef = storageRef(storage, 'images');
    
    const sendButton = document.getElementById("sendButton");
    const claimButton = document.getElementById("claimButton");
    const emailInput = document.getElementById("emailInput");
    const passwordInput = document.getElementById("passwordInput");
    const messageInput = document.getElementById("messageInput");
    const chatbox = document.getElementById("chatbox");
    const openChatButton = document.getElementById("openChatButton");
    const statusMessageDiv = document.getElementById("statusMessage");
    const userInfoDiv = document.getElementById("userInfo");
    const signOutButton = document.getElementById("signOutButton");
    const announcementDiv = document.getElementById('announcement');
    const closeAnnouncementDiv = document.getElementById('close-announcement');

    // Reference to publicAnnouncement in your database
    const announcementRef = dbRef(database, 'publicAnnouncement');


    document.addEventListener("DOMContentLoaded", function() {
        if (!isInnerHTML) {
            executeScriptLogic();
        console.log("AAAAAAAA")

        }
    });

    if (isInnerHTML) {
        executeScriptLogic();
        player.playVideo();

        console.log("IS INNER THEREFORE START NOW")
    }

    function executeScriptLogic() {
        console.log("EXECUTING SCRIPT!!!!!!!!!!!!!!!!!!"); 
        
        // if (window.location.href.includes("reizorbean.netlify.app")) {
        let allowIn = true;

        const siteDataRef = dbRef(database, 'siteData/siteURL');
        const sitePWRef = dbRef(database, 'siteData/pw');
        
        
        
        get(sitePWRef).then((snapshot) => {
            const thepw = snapshot.val();
            
            console.log(thepw); 
        
        
        get(siteDataRef).then((snapshot) => {
                const siteURL = snapshot.val();
                console.log(siteURL); // Outputs: "https://example.com"
        
        
        if (typeof(thepw) !== "undefined"){
            
            if (!window.location.href.includes(siteURL))
            {
                let magicpw = "";
                magicpw = prompt("Please enter the password:");
                
                if (magicpw === thepw && magicpw) {
                    allowIn = true;
                } else {
                    allowIn = false;
                }
            }
        }else{
            
            allowIn = false;
            
        }
       
        if (allowIn) {
                
            document.body.classList.remove('hide');
            

                // Array of YouTube links
        let musiclist = [];
        // Function to create iframes from the YouTube links
        function embedYouTubeVideos(videoList) {
            const container = document.getElementById("videoContainer"); // Get the container div
            
            videoList.forEach(link => {
                // Extract video ID from the YouTube link
                const videoId = link.split("v=")[1];
                const ampersandPosition = videoId.indexOf("&");
                if (ampersandPosition !== -1) {
                    videoId = videoId.substring(0, ampersandPosition);
                }

                // Create the iframe element
                const iframe = document.createElement("iframe");
                iframe.className = "musicstashembed";
                iframe.width = "260";
                iframe.height = "147";
                iframe.src = `https://www.youtube.com/embed/${videoId}`;
                iframe.title = "YouTube video player";
                iframe.frameBorder = "0";
                iframe.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture";
                iframe.allowFullscreen = true;

                // Append the iframe to the container
                container.appendChild(iframe);
            });
        }

            // Fetch the music list from the JSON file
            (async () => {
                const recipes = await data();
                    musiclist = recipes.music; // Assuming your JSON structure has a "music" key
                    console.log(musiclist); // This will log the music list to the console

            // Call the function to embed videos
            embedYouTubeVideos(musiclist);
        })();   

        
        let announcementLink = "";

            // Listen for value changes using onValue
            onValue(announcementRef, (snapshot) => {
            const announcementData = snapshot.val();
            announcementLink = announcementData.link;
            if (announcementData && announcementData.message) {
                announcementDiv.textContent = `${announcementData.title}: ${announcementData.message}`; // Update the announcement text
                announcementDiv.style.display = 'block'; // Show the announcement
                closeAnnouncementDiv.style.display = 'block';
                document.getElementById('announcement').title = announcementLink;
                console.log(announcementDiv.textContent);

            } else {
                announcementDiv.style.display = 'none'; // Hide if no announcement
                console.log("No ann");

            }
        });
        window.closeAnn = function() {
            announcementDiv.style.display = 'none';
            closeAnnouncementDiv.style.display = 'none';
        }
        window.goToAnn = function() {
            if (announcementLink === ""){
            } else{
                const userConfirmed = confirm(`Are you sure you want to go to ${announcementLink}?`);
                
                // If the user confirms, navigate to the link
                if (userConfirmed) {
                    window.open(announcementLink, '_blank');
                }
            }
        }
        
        onAuthStateChanged(auth, (user) => {
            checkUser(user);
        });
        function checkUser() {
            // CHECK CURRENT USER
            const user = auth.currentUser;

            if (user) {
                statusMessageDiv.textContent = "Hello, human.";

                const userEmail = user.email;
                const userRef = dbRef(database, `users/${auth.currentUser.uid}`);

                // Fetch display name from the database
                onValue(userRef, (snapshot) => {
                    const userData = snapshot.val();
                    const displayName = userData ? userData.displayName || 'Anonymous' : 'Anonymous';

                    updateUIForLoggedInUser(displayName); // Use the actual displayName here
                    signOutButton.style.display = "block";
                });
            }
        }

        userInfoDiv.textContent = "Anonymous";
        function loadMessages() {
            statusMessageDiv.textContent = "Loading messages...";
            setTimeout(() => {
            const messagesRef = dbRef(database, 'publicChatRooms/defaultRoom/messages');
            onValue(messagesRef, (snapshot) => {
                chatbox.style.display = 'flex' ;
                openChatButton.style.display ='none';

                const messages = snapshot.val();
                const messagesDiv = document.getElementById("messages");
                messagesDiv.innerHTML = '';

                for (const key in messages) {
                    const message = messages[key];
                    const messageElement = document.createElement("div");
                    messageElement.className = "message";
                    messageElement.textContent = `${message.name || 'Anonymous'}: ${message.text} (sent at ${new Date(message.timestamp).toLocaleDateString()} ${new Date(message.timestamp).toLocaleTimeString()})`;
                    messagesDiv.appendChild(messageElement);
                }
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                sendButton.disabled = false;
            }, (error) => {
                console.error("Error reading data:", error);
                statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                sendButton.disabled = true;
            });
            statusMessageDiv.textContent = "";}, 310);
        }
        sendButton.disabled = true;
        loadMessages();
        let isSendingMessage = false;
        let isBusySending = false;

        let existingDisplayNames = [];

        const publicDisplayNamesRef = dbRef(database,'publicDisplayNames');

        onValue(publicDisplayNamesRef, (snapshot) => {
        const allDisplayNames = snapshot.val();
        // Extract display names from the data
        existingDisplayNames = Object.values(allDisplayNames || {}).map(user => user.displayName);
        
            // Log all display names
            //console.log("All Public Display Names:", existingDisplayNames);
        }, (error) => {
            console.error("Error fetching public display names:", error);
        });

        let openedClaimBox = false;

        window.claimDisplayName = function() {
            if (!openedClaimBox){
                // Display a confirmation dialog
                const userConfirmed = confirm("Please create a random password you don't use elsewhere. Reserve it solely for this page. I can view the email address but won't have access to it");

                // If the user clicks Cancel, return early
                if (!userConfirmed) {
                    return;
                }
            }

            const claimDiv = document.getElementById('claim');
            if (claimDiv.style.display === "none" || claimDiv.style.display === "") {
                openedClaimBox = true;
                claimDiv.style.display = "contents"; // Show the contents
            } else {
                openedClaimBox = false;
                claimDiv.style.display = "none"; // Hide the contents
            }
        }

        // ---------------------------------------------------------SENDING A MESSAGE------------------------------------------
        // ---------------------------------------------------------SENDING A MESSAGE------------------------------------------
        // ---------------------------------------------------------SENDING A MESSAGE------------------------------------------
        window.sendMessage = function() {

        if (isSendingMessage) return;
        isSendingMessage = true;

        console.log("sendMessage called");
        sendButton.disabled = true;
        statusMessageDiv.textContent = "Loading...";

        setTimeout(() => {
        const messageText = messageInput.value.trim();
        const userEmail = emailInput.value.trim();
        const userPassword = passwordInput.value.trim();

        if (messageText === "") {
            statusMessageDiv.textContent = "Input is required.";
            sendButton.disabled = false;
            return;
        }

        // Get the current user
        const user = auth.currentUser;

        if (user) {
            console.log("Sending with user");

            const userEmail = user.email;
            const userRef = dbRef(database, `users/${auth.currentUser.uid}`);
            if (displayNameInput.value !== "") {
                if (existingDisplayNames.includes(displayName)) {
                    console.log("ALREADY TAKEN");
                    statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                    sendButton.disabled = false;
                    return; // Return false if the name is taken
                }
                saveDisplayName(userEmail, displayNameInput.value.trim());
            }
            // Fetch display name from the database
            get(userRef).then((snapshot) => {
                if (isBusySending) return;
                isBusySending = true;

                const userData = snapshot.val();
                const displayName = userData.displayName || 'Anonymous';

                const messageData = {
                    name: displayName,
                    text: messageText,
                    timestamp: Date.now(),
                    ownerId: auth.currentUser.uid
                };

                push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                    .then(() => {
                        updateUIForLoggedInUser(displayName);
                        messageInput.value = "";
                        statusMessageDiv.textContent = `Message sent. ${new Date(Date.now()).toLocaleTimeString()}`;
                        passwordInput.value = ""; // Clear password
                        displayNameInput.value = "";
                    })
                    .catch((error) => {
                        console.error("Error writing data:", error);
                        statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                    });
            });
        } 
        else {
        // Check if email is provided
        if (userEmail === "") {
                // Send as anonymous
                const messageData = {
                    name: "Anonymous",
                    text: messageText,
                    timestamp: Date.now(),
                    ownerId: "anon"
                };
                push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                    .then(() => {
                        console.log("anonymous push called");
                        messageInput.value = "";
                        statusMessageDiv.textContent = "Message sent as Anonymous.";
                        userInfo.textContent = "Anonymous";
                        sendButton.disabled = false;
                    })
                    .catch((error) => {
                        console.error("Error writing data:", error);
                        statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                        sendButton.disabled = true;
                    });
            } else {
                    // Attempt to login/register
                    signInWithEmailAndPassword(auth, userEmail, userPassword)
                        .then(() => {
                            sendButton.disabled = true;
                            if (displayNameInput.value !== "") {
                                if (existingDisplayNames.includes(displayNameInput.value)) {
                                    console.log("ALREADY TAKEN");
                                    statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                                    sendButton.disabled = false;
                                    return; // Return false if the name is taken
                                }
                                saveDisplayName(userEmail, displayNameInput.value.trim());
                            }
                            // Fetch the display name from the database
                            const userRef = dbRef(database, `users/${auth.currentUser.uid}`);
                            get(userRef).then((snapshot) => {
                                if (isBusySending) return;
                                    isBusySending = true;

                                const userData = snapshot.val();
                                const displayName = userData.displayName || 'Error loading name';

                                const messageData = {
                                    name: displayName, // Use display name from database
                                    text: messageText,
                                    timestamp: Date.now(),
                                    ownerId: auth.currentUser.uid
                                };
                                
                                push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                                .then(() => {
                                    console.log("signed in sent message called");
                                    statusMessageDiv.textContent = "";
                                    
                                    messageInput.value = "";
                                    passwordInput.value = ""; // Clear password
                                    updateUIForLoggedInUser(displayName);
                                    displayNameInput.value = "";
                                    
                                    sendButton.disabled = false;
                                    
                                })
                                .catch((error) => {
                                    console.error("Error writing data:", error);
                                    statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                                    sendButton.disabled = true;
                                });  
                            }).catch((error) => {
                                console.error('Error fetching user data on sign in!!:', error);
                                statusMessageDiv.textContent = "Error";
                            });
                        })
                        .catch((error) => {
                            sendButton.disabled = true;

                            if (error.code === 'auth/user-not-found') {
                                // Not registered, attempt to register
                                let displayName = displayNameInput.value.trim();
                                displayName = displayName === "" ? generateDisplayNameWithToken() : displayName;
                                if (existingDisplayNames.includes(displayName)) {
                                    console.log("ALREADY TAKEN");
                                    statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                                    sendButton.disabled = false;
                                    return; // Return false if the name is taken
                                }
                                console.log("Sending with user2");
                                createUserWithEmailAndPassword(auth, userEmail, userPassword)
                                    .then(() => {
                                        if (!saveDisplayName(userEmail, displayName)){
                                            console.log("FAILED DISPLAY NAME");
                                            statusMessageDiv.textContent =  "Failed.";
                                        }
                                        const messageData = {
                                            text: messageText,
                                            name: displayName,
                                            timestamp: Date.now(),
                                            ownerId: auth.currentUser.uid
                                        };

                                        push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                                            .then(() => {
                                                statusMessageDiv.textContent = "";
                                                console.log("registration 01 push called");
                                                messageInput.value = "";
                                                passwordInput.value = ""; // Clear password
                                                updateUIForNewRegisteredInUser(displayName);
                                                sendButton.disabled = false;
                                            })
                                            .catch((error) => {
                                                console.error("Error writing data:", error);
                                                statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                                                sendButton.disabled = true;
                                            });
                                    })
                                    .catch((error) => {
                                        statusMessageDiv.textContent = error.message;
                                    });
                                
                            } else if (error.code === 'auth/invalid-credential') {
                                console.log("Sending with user3");

                                let displayName = displayNameInput.value.trim();
                                displayName = displayName === "" ? generateDisplayNameWithToken() : displayName;
                                if (existingDisplayNames.includes(displayName)) {
                                    console.log("ALREADY TAKEN");
                                    statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                                    sendButton.disabled = false;
                                    return; // Return false if the name is taken
                                }
                                    createUserWithEmailAndPassword(auth, userEmail, userPassword)
                                    .then(() => {
                                            if (!saveDisplayName(userEmail, displayName)){
                                            console.log("FAILED DISPLAY NAME");
                                            statusMessageDiv.textContent =  "Failed.";
                                        }
                                        const messageData = {
                                            text: messageText,
                                            name: displayName,
                                            timestamp: Date.now(),
                                            ownerId: auth.currentUser.uid
                                        };

                                        push(dbRef(database, 'publicChatRooms/defaultRoom/messages'), messageData)
                                            .then(() => {
                                                statusMessageDiv.textContent = "";
                                                console.log("registration 02 push called");
                                                messageInput.value = "";
                                                passwordInput.value = ""; // Clear password
                                                updateUIForNewRegisteredInUser(displayName);
                                                sendButton.disabled = false;

                                            })
                                            .catch((error) => {
                                                console.error("Error writing data:", error);
                                                statusMessageDiv.textContent = "Maintenance! Come back tomorrow or later.";
                                                sendButton.disabled = true;
                                            });
                                    })
                                    .catch((error) => {
                                        statusMessageDiv.textContent = "Something went wrong. Please try it again or nech an696 9 at gmaildotcom for support. or make sure your password is correct.";
                                    });
                                
                            } else if (error.code === 'auth/missing-password') {
                                statusMessageDiv.textContent =  "Enter password.";
                            } else {
                                // Handle other errors
                                statusMessageDiv.textContent = "Too many attempts or something went wrong. Please try it again later or nech an696 9 at gmaildotcom for support. - or make sure your password is correct.";
                            }
                        });
                }
            }
            isSendingMessage = false;
            isBusySending = false;

            }, 1250);

            isSendingMessage = false;
            isBusySending = false;
        }
        let isBusyUpdatingName = false;


        async function saveDisplayName(userEmail, displayName) {
            if (isBusyUpdatingName) return false; // Return false if already busy
            
            isBusyUpdatingName = true;

            if (existingDisplayNames.includes(displayName)) {
                console.log("ALREADY TAKEN");
                statusMessageDiv.textContent = "Display name already taken. Please choose another.";
                sendButton.disabled = false;
                isBusyUpdatingName = false; // Reset the busy state
                return false; // Return false if the name is taken
            }

            const userRef = dbRef(database, `users/${auth.currentUser.uid}`);
            const publicDisplayNamesRef  = dbRef(database, `publicDisplayNames/${auth.currentUser.uid}`);
            try {
                await update(userRef, { 
                    displayName, 
                    email: userEmail 
                });
                await set(publicDisplayNamesRef, { displayName })
                .then(() => {
                    console.log("Display name updated successfully!");
                })
                .catch((error) => {
                    console.error("Error updating display name:", error);
                });

                statusMessageDiv.textContent = "Display name changed.";
                console.log("Display name changed.");
                return true; // Return true on success
            } catch (error) {
                console.error("Error writing data:", error);
                statusMessageDiv.textContent = error.message;
                return false; // Return false on error
            } finally {
                isBusyUpdatingName = false; // Reset the busy state
            }
        }


        function generateDisplayNameWithToken() {
            let randomToken;
            
            // Generate a unique token
            do {
                randomToken = Math.random().toString(36).substring(2, 12);
            } while (existingDisplayNames.includes(`User_${randomToken}`)); // Check for duplicates

            return `User_${randomToken}`; // Return the unique display name
        }

        function updateUIForLoggedInUser(displayName) {
            passwordInput.style.display = "none";
            displayNameInput.style.display = "none";
            userInfo.textContent = `Welcome ${displayName}.`;
        }

        function updateUIForNewRegisteredInUser(displayName) {
            passwordInput.style.display = "none";
            displayNameInput.style.display = "none";
            userInfo.textContent = `Welcome ${displayName}.`;
        }

        window.toggleChatbox = function() {
            const isMinimized = chatbox.style.display === 'none';
            chatbox.style.display = isMinimized ? 'flex' : 'none';
            openChatButton.style.display = isMinimized ? 'none' : 'block';
        }

        window.forgotPassword = function() {
            const userEmail = emailInput.value.trim();

            if (userEmail === "") {
                statusMessageDiv.textContent = "Please enter your email address.";
                return;
            }

            sendPasswordResetEmail(auth, userEmail)
                .then(() => {
                    statusMessageDiv.textContent = "If you are registered, you will receive a password reset email.";
                })
                .catch((error) => {
                    console.error(error); 
                    statusMessageDiv.textContent = "If you are registered, you will receive a password reset email.";
                });
        }
        function resetUIForLoggedOutUser() {
            passwordInput.style.display = "block"; // Show password input
            displayNameInput.style.display = "block"; // Show display name input
            emailInput.value = ""; // Clear email input
            passwordInput.value = ""; // Clear password input
            displayNameInput.value = ""; // Clear display name input
            userInfo.textContent = "";
            signOutButton.style.display = "none";
        }

        window.signOut = function() {
            signOut(auth)
                .then(() => {
                    // Sign-out successful.
                    statusMessageDiv.textContent = "You have been signed out.";
                    resetUIForLoggedOutUser(); // Reset UI for logged out state
                })
                .catch((error) => {
                    console.error("Error signing out:", error);
                    statusMessageDiv.textContent = "Error signing out. Please try again.";
                });
        };


















        // the draggables

        let showDraggables = true;
        if (showDraggables) {
            
                listAll(imagesRef).then((res) => {
            if (res.items.length > 0) {
                res.items.forEach((itemRef) => {
                    // Get download URL for each image
                    getDownloadURL(itemRef).then((url) => {
                        createDraggableImage(url); // Create draggable image for each URL
                    }).catch((error) => {
                        console.error("Error getting image URL:", error);
                    });
                });
            } else {
                console.log("No images found.");
            }
            }).catch((error) => {
                console.error("Error listing images:", error);
            });

            // Function to create draggable images
            function createDraggableImage(imageUrl) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.className = 'draggable';
                img.style.position = 'absolute';
                img.style.width = '100px'; // Set a width
                img.style.height = '100px'; // Set a height
                img.setAttribute('draggable', false); // Prevent default dragging behavior

                const maxWidth = window.innerWidth - 100; // Adjust for element width
                const maxHeight = window.innerHeight - 100; // Adjust for element height
                const randomLeft = Math.floor(Math.random() * maxWidth);
                const randomTop = Math.floor(Math.random() * maxHeight);
                img.style.left = randomLeft + 'px';
                img.style.top = randomTop + 'px';

                document.body.appendChild(img);
                makeDraggable(img);
            }

            // Function to make images draggable on both desktop and mobile
            function makeDraggable(element) {
                let offsetX, offsetY;

                // Desktop: mouse down event
                element.addEventListener('mousedown', (e) => {
                    e.preventDefault(); // Prevent default behavior like selecting text or dragging

                    // Calculate the offset between the mouse click position and the image's position
                    const rect = element.getBoundingClientRect();
                    offsetX = e.clientX - rect.left; // Horizontal offset
                    offsetY = e.clientY - rect.top; // Vertical offset

                    // Add event listeners for moving the image
                    document.addEventListener('mousemove', mouseMoveHandler);
                });

                // Mobile: touch start event
                element.addEventListener('touchstart', (e) => {
                    e.preventDefault(); // Prevent default behavior like scrolling

                    const touch = e.touches[0]; // Only consider the first touch point
                    const rect = element.getBoundingClientRect();
                    offsetX = touch.clientX - rect.left; // Horizontal offset
                    offsetY = touch.clientY - rect.top; // Vertical offset

                    // Add event listeners for moving the image on touch devices
                    document.addEventListener('touchmove', touchMoveHandler);
                });

                function mouseMoveHandler(e) {
                    // Calculate the new position of the image, accounting for scroll
                    const newX = e.clientX - offsetX + window.scrollX; // Horizontal position, adjusted for horizontal scroll
                    const newY = e.clientY - offsetY + window.scrollY; // Vertical position, adjusted for vertical scroll

                    moveElementToPosition(newX, newY);
                }

                function touchMoveHandler(e) {
                    const touch = e.touches[0]; // Only consider the first touch point
                    const newX = touch.clientX - offsetX + window.scrollX; // Horizontal position, adjusted for horizontal scroll
                    const newY = touch.clientY - offsetY + window.scrollY; // Vertical position, adjusted for vertical scroll

                    moveElementToPosition(newX, newY);
                }

                function moveElementToPosition(newX, newY) {
                    const viewportWidth = window.innerWidth + window.scrollX; // Adjust for horizontal scroll
                    const viewportHeight = window.innerHeight + window.scrollY; // Adjust for vertical scroll

                    // Ensure the image stays within the viewport
                    const constrainedX = Math.max(0, Math.min(newX, viewportWidth - element.offsetWidth));
                    const constrainedY = Math.max(0, Math.min(newY, viewportHeight - element.offsetHeight));

                    // Update the position of the image
                    element.style.left = `${constrainedX}px`;
                    element.style.top = `${constrainedY}px`;
                }

                // Stop moving the image when mouse is released
                document.addEventListener('mouseup', () => {
                    document.removeEventListener('mousemove', mouseMoveHandler);
                });

                // Stop moving the image when touch ends
                document.addEventListener('touchend', () => {
                    document.removeEventListener('touchmove', touchMoveHandler);
                });
            }
        }



    }  else {
        document.body.innerHTML = 'Error. Come back again later.'; 
        confirm("Error. Come back again later.");

        return; 
        }

                
       }).catch((error) => {
        console.error("Error fetching site data:", error);
    });
       }).catch((error) => {
    console.error("Error fetching PW data:", error);
});


}

</script>



<!-- typewriter -->


<div id="typebns">
    <p id="typewriter" class= "bns"></p>
    <p id="blinker-pos"></p>
    </div>
    <script>
          const text = "Beans is and will forever be my one and only!";
        const typewriterElement = document.getElementById("typewriter");
        const blinkerElement = document.getElementById("blinker-pos");
        let index = 0;
     // Create and append the cursor at the beginning
        const blinkCursor = document.createElement("span");
        blinkCursor.className = "cursor"; // Apply the cursor styles
        blinkerElement.appendChild(blinkCursor); // Append cursor initially
        function typeWriter() {
            if (index < text.length) {
                typewriterElement.textContent += text.charAt(index); // Add the next character
                index++;
                
                // Move the cursor to the end
                setTimeout(typeWriter, 160); // Adjust the speed (160ms between characters)
            } else {
                // Optionally, you can remove the cursor after some time
                setTimeout(() => {
                    blinkerElement.remove(); // Remove the cursor
                }, 3000); // Adjust this value to keep the cursor longer or shorter
            }
        }
    
        // Start the typewriter effect
        typeWriter();
    </script>




</div>
</div>



</body>
</html>
